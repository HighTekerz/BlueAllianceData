import numpy as np
import scipy as sp
import time
from scipy import linalg
import requests
import json
#authorization key needed touse TBA API
auth={'X-TBA-Auth-Key':'WpZWImrGaWBkNJIIbuvmw6CYDDP52XxQf8XrILyI0itHAcZDaGFVn3z72SlRIjF8'}
def removeFRC(teamKey): # converts teram keys like 'frc948' to 948 to make it so stuff sorts properly later
    return int(teamKey[3:])
def removeNewLine(string): #converts JSON of <something> keys API to a python data
    return(json.loads(string[2:len(string)-1].replace('\\n','').replace("\\",'')))
def TBAPull(directory): #pulls specific info from tba api and makes it into python usable format
    return(removeNewLine(str(requests.get('http://www.thebluealliance.com/api/v3/'+directory,headers=auth).content)))
class Event:
    colors = ['blue','red']
    #fill these in for all years later
    #metrics where alliance partners "shouldn't" have any significant impact such as crossing line in auto 
    teamMetrics = {2018:[],
                   2019:[],
                   2020:['initLineRobot','endgameRobot']
                  }
    #sources of points where defence is judged to be moot due to causing
    nonContestedMetrics = {2018:[],
                           2019:[],
                           2020:['autoCellsBottom','autoCellsOuter','autoCellsInner','autoCellPoints','endgameRungIsLevel','adjustPoints','controlPanelPoints','autoPoints','endgamePoints']
                          }
    #sources of points where defence could be reasonably played, everything else
    allianceMetrics = {2018:[],
                        2019:[],
                        2020:['teleopCellsBottom','teleopCellsOuter','teleopCellsInner']
                      }
    #converts boolean data from TBA to numbers
    #can't fill out until I know what the possible responses for 2020 are
    tbaTranslation = {2018:{'climbToPoint':{'None':0, 'Levitate':0, 'Parking':5,'Climbing':30, 'Unknown':0},'autoRunToPoints':{'None':0, 'AutoRun':5}},
                      2019:{'endPoints':{'None':0,'HabLevel1':3,'HabLevel2':6,'HabLevel3':12},'bayToPoints':{'None':0,'Panel':2,'PanelAndCargo':5},'preBayToPoints':{'Cargo':0,'Panel':2},'preLevelToPoints':{'None':0,'HabLevel1':3,'HabLevel2':6,'HabLevel3':6},'lineToPoints':{'None':0,'CrossedHabLineInSandstorm':1}},
                      2020:{}
                     }
    weights = {2018:[0, 2, 2, 1, 1, 1, -1, 1, 1],
               2019:[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,0,0,-1,0,0,1,0,1],
               2020:[ ]
              }
    def __init__(self, year, key):
        if type(year)!=int:
            raise Exception('Years are ints')
        elif year not in range(2019,2021):
            raise Exception('Year not implemented')
        elif type(key)!=str:
            raise Exception('Key must be string')
        #add something to make sure the year key combo is valid
        self.eventKey = str(year)+key
        self.nonContestedMetrics = self.nonContestedMetrics[year]
        self.allianceMetrics = self.allianceMetrics[year]
        self.teamMetrics = self.teamMetrics[year]
        self.tbaTranslation = self.tbaTranslation[year]
        self.weights = self.weights[year]
        eventKey = key+str(year)
    #def rollCall(self):
    def teams(self):
        #figure out a better way to change all elements of list than creating new one
        teamsPre = TBAPull('event/'+self.eventKey+'/teams/keys')
        teamsList = [removeFRC(x) for x in teamsPre]
        teamsList.sort()
        self.teamsList = teamsList
        self.noTeams = len(teamsList)
    def matches(self):
        allMatches = TBAPull('event/'+self.eventKey+'/matches/keys')
        quals = [Match(match) for match in allMatches if 'f' not in match]
        finals = [Match(match) for match in allMatches if 'f' in match]
        quals.sort()
        self.noQuals = len(quals)
        self.quals = quals
        self.finals = finals
    def participation(self): #creates incidence matrix for teams and events
        #todo, determine whether any teams were absent
        blueParticipation = np.zeros((self.noQuals,self.noTeams))
        redParticipation = np.zeros((self.noQuals,self.noTeams))
        for match in self.quals:
            for team in match.blue:
                blueParticipation[int(match.matchNo)-1][(self.teamsList).index(team)] = 1
        for match in self.quals:
            for team in match.red:
                redParticipation[int(match.matchNo)-1][(self.teamsList).index(team)] = 1
        self.blueMatrix = blueParticipation
        self.redMatrix = redParticipation
class Match:
    auth={'X-TBA-Auth-Key':'WpZWImrGaWBkNJIIbuvmw6CYDDP52XxQf8XrILyI0itHAcZDaGFVn3z72SlRIjF8'}
    def __init__(self, matchKey):
        self.matchKey = matchKey
        split = matchKey.split('_')
        #rename temp
        temp = split[1]
        self.eventKey = split[0]
        #the handling of these case feels really awful
        if 'sf' in temp:
            self.matchType = 'sf'
            self.matchNo = temp[2:]
        elif 'qf' in temp:
            self.matchType = 'qf'
            self.matchNo = temp[2:]
            
        elif 'f' in temp:
            self.matchType = 'f'
            self.matchNo = temp[1:]
        else:
            self.matchType = 'qm'
            self.matchNo = temp[2:]
    def score(self):
        matchData = TBAPull('match/'+self.matchKey)
        self.blue = [removeFRC(x) for x in matchData["alliances"]['blue']['team_keys']]
        self.red = [removeFRC(x) for x in matchData["alliances"]['blue']['team_keys']]
        self.blueScore = matchData['score_breakdown']['blue']
        self.redScore = matchData['score_breakdown']['red']
        self.winner = matchData['winning_alliance']
        if matchData['actual_time']==None:
            self.happened = False
        else:
            self.happened = True
    def __eq__(self, second):
        if self.eventKey == second.eventKey:
            if self.matchKey == second.matchKey:
                return True
            else:
                return False
        else:
            raise Exception('Must be from same event')
    def __lt__(self, second):
        if self.eventKey == second.eventKey:
            if self.matchType == second.matchType == 'qm':
                return(int(self.matchNo)<int(second.matchNo))
            else:
                raise Exception('Comparison between match types other than qualifiers not implemented')
        else:
            raise Exception('Must be from same event')
class Team: #more functionality will be added eventually but I'm not sure what
    def __init__(self, number):
        self.number = number
    def __eq__(self, second):
        return(self.number==second.number)
    def __lt__(self, second):
        return(self.number<second.number)
    def events(self, year): #generates dict of event key name pairs for a given year
        eventList = TBAPull('team/frc'+str(self.number)+'/events/'+str(year)+'/simple')
        self.eventList = dict([(event['key'],event['name']) for event in eventList])
