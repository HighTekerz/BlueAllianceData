import numpy as np
import scipy as sp
import time
from scipy import sparse
from scipy import linalg
import requests
import json
def coolData(eventKey):
    authorization = {'X-TBA-Auth-Key':'y0P1WCKJgxgQWgov5mSK2LaR8tRhthEeZp9puDNz045CkNm8VUhuwPw0E2qOllFD'}
    test = requests.get('http://www.thebluealliance.com/api/v3/event/'+eventKey+'/teams/keys', headers=authorization)
    teamKeys = str(test.content)
    def removeNewLine(string): #converts JSON of <something> keys API to a python data
        length = len(string) #this function may not be needed
        temp1 = string[2:length-1]
        temp2 = temp1.replace('\\n','')
        return(json.loads(temp2))
    teamsList = removeNewLine(teamKeys)
    noTeams = len(teamsList)
    #counts the number of qualifiers at event
    matches = str((requests.get('http://www.thebluealliance.com/api/v3/event/' + eventKey + '/matches/keys', headers=authorization)).content)
    count = True
    index = 1
    while count:
        index += 1
        count = matches.count(str(index))
    noQual = index-1
    eventData = []
    start2 = time.time()
    for x in range(1, noQual+1): #this just downloads and stores all the match data in a big list so it can be accessed more easily later
        eventData.append(removeNewLine(str((requests.get('http://www.thebluealliance.com/api/v3/match/' + eventKey + '_qm' + str(x), headers=authorization)).content)))
    #put all the different scoring metrics you care about in below array
    allMetrics = {'totalPoints':'overallScore', 'autoRunPoints':'runVector', 'autoSwitchOwnershipSec':'switchAuto', 'autoScaleOwnershipSec':'scaleAuto','teleopSwitchOwnershipSec':'switchTele', 'teleopScaleOwnershipSec':'scaleTele', 'vaultPoints':'vaultVector', 'foulPoints':'oof', 'climbPoints':'climbVector'}
    syntheticOverallContributionWeights = [0, 1, 2, 2, 1, 1, 1, -1, 1] # edit this to calculate SOC
    for metrics in allMetrics: #if a metric has weird needs, use "if else" to modify below loop
        allMetrics[metrics] = np.zeros((2*noQual, 1))
    participationMatrix = np.zeros((noQual*2, noTeams*2))#denotes which teams were in which matches
    def climbPointsNoLevitate(match, color): #eliminates points from levitate
        total = 0
        translate = {'None':0, 'Levitate':0, 'Parking':5,'Climbing':30, 'Unknown':0}
        for x in range(0,3):
            total += translate[eventData[match]['score_breakdown'][str(color)]['endgameRobot'+str(x+1)]]
        return(total)
    participationMatrix = np.zeros((noQual*2, noTeams*2)) # denotes which teams were in which matches
    reducedMatrix = np.zeros((noQual*2, noTeams))
    colors = ['blue', 'red']
    for match in range(0, noQual): #if a metric has weird needs, use "if else" to modify below loop
        for x in range(0,2):
            for teams in range(0,3): # put team specific stuff in this section, make sure to duplicate
                    teamKey = eventData[match]['alliances'][colors[x]]['team_keys'][teams]
                    participationMatrix[match+x*noQual, teamsList.index(teamKey)] = 1
                    reducedMatrix[match+x*noQual, teamsList.index(teamKey)] = 1
                    participationMatrix[match+noQual-x*noQual, noTeams+teamsList.index(teamKey)] = -1
            for metrics in allMetrics:
                if metrics=='foulPoints':
                    allMetrics[metrics][match+noQual-x*noQual] = eventData[match]['score_breakdown'][colors[x]][metrics]
                elif metrics=='climbPoints':
                    allMetrics[metrics][match +x*noQual] = climbPointsNoLevitate(match, colors[x])
                else:
                    allMetrics[metrics][match+x*noQual] = eventData[match]['score_breakdown'][colors[x]][metrics]
    pseudoInverse = linalg.pinv(reducedMatrix)
    teamDataArray = np.zeros((noTeams, 0))
    for metric in allMetrics: # '@' is what numpy uses for matrix multiplication
        teamDataArray = np.concatenate((teamDataArray, pseudoInverse@allMetrics[metric]), axis=1)
    for x in range(0, noTeams):
        print(teamsList[x], np.dot(teamDataArray[x], syntheticOverallContributionWeights), teamDataArray[x])
